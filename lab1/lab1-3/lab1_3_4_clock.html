<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>滴答滴答（时钟中断） &mdash; 2023级NKU操作系统实验指导书 1.0.0 文档</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/translations.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="实验报告要求" href="../lab1-4/lab1_4_lab_requirement.html" />
    <link rel="prev" title="中断处理程序" href="lab1_3_3_trap.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            2023级NKU操作系统实验指导书
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../README/README.html">欢迎来到ucore step-by-step的世界</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab0/index.html">lab0: 预备起</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab0.5/index.html">lab0.5: 比麻雀更小的麻雀(最小可执行内核)</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">lab1: 断, 都可以断</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#id1">本章内容</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../lab1-1/lab1_1_goals.html">实验目的：</a></li>
<li class="toctree-l3"><a class="reference internal" href="../lab1-2/index.html">实验目的</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">中断与中断处理流程</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="index.html#id2">本节内容</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../lab1-4/lab1_4_lab_requirement.html">实验报告要求</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../lab2/index.html">lab2:物理内存和页表</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab3/index.html">lab3:缺页异常和页面置换</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab4/index.html">lab4:进程管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab5/index.html">lab5:用户程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab6/index.html">lab6 进程调度</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab7/index.html">lab7 同步互斥</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab8/index.html">Lab8 文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../appendix/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">2023级NKU操作系统实验指导书</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">lab1: 断, 都可以断</a></li>
          <li class="breadcrumb-item"><a href="index.html">中断与中断处理流程</a></li>
      <li class="breadcrumb-item active">滴答滴答（时钟中断）</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/lab1/lab1-3/lab1_3_4_clock.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>滴答滴答（时钟中断）<a class="headerlink" href="#id1" title="永久链接至标题"></a></h1>
<p>时钟中断需要CPU硬件的支持。CPU以”时钟周期”为工作的基本时间单位，对逻辑门的时序电路进行同步。</p>
<p>我们的“时钟中断”实际上就是”每隔若干个时钟周期执行一次的程序“。</p>
<p>”若干个时钟周期“是多少个？太短了肯定不行。如果时钟中断处理程序需要100个时钟周期执行，而你每50个时钟周期就触发一个时钟中断，那么间隔时间连一个完整的时钟中断程序都跑不完。如果你200个时钟周期就触发一个时钟中断，那么CPU的时间将有一半消耗在时钟中断，开销太大。一般而言，可以设置时钟中断间隔设置为CPU频率的1%，也就是每秒钟触发100次时钟中断，避免开销过大。</p>
<p>我们用到的RISCV对时钟中断的硬件支持包括：</p>
<ul class="simple">
<li><p>OpenSBI提供的<code class="docutils literal notranslate"><span class="pre">sbi_set_timer()</span></code>接口，可以传入一个时刻，让它在那个时刻触发一次时钟中断</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rdtime</span></code>伪指令，读取一个叫做<code class="docutils literal notranslate"><span class="pre">time</span></code>的CSR的数值，表示CPU启动之后经过的真实时间。在不同硬件平台，时钟频率可能不同。在QEMU上，这个时钟的频率是10MHz, 每过1s, <code class="docutils literal notranslate"><span class="pre">rdtime</span></code>返回的结果增大<code class="docutils literal notranslate"><span class="pre">10000000</span></code></p></li>
</ul>
<blockquote>
<div><p>趣闻</p>
<p>在RISCV32和RISCV64架构中，<code class="docutils literal notranslate"><span class="pre">time</span></code>寄存器都是64位的。</p>
<p><code class="docutils literal notranslate"><span class="pre">rdcycle</span></code>伪指令可以读取经过的时钟周期数目，对应一个寄存器<code class="docutils literal notranslate"><span class="pre">cycle</span></code></p>
</div></blockquote>
<p>注意，我们需要“每隔若干时间就发生一次时钟中断”，但是OpenSBI提供的接口一次只能设置一个时钟中断事件。我们采用的方式是：一开始只设置一个时钟中断，之后每次发生时钟中断的时候，设置下一次的时钟中断。</p>
<p>在clock.c里面初始化时钟并封装一些接口</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//libs/sbi.c</span>

<span class="c1">//当time寄存器(rdtime的返回值)为stime_value的时候触发一个时钟中断</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">sbi_set_timer</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">stime_value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">sbi_call</span><span class="p">(</span><span class="n">SBI_SET_TIMER</span><span class="p">,</span><span class="w"> </span><span class="n">stime_value</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// kern/driver/clock.c</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;clock.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;defs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sbi.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;riscv.h&gt;</span><span class="cp"></span>

<span class="c1">//volatile告诉编译器这个变量可能在其他地方被瞎改一通，所以编译器不要对这个变量瞎优化</span>
<span class="k">volatile</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">ticks</span><span class="p">;</span><span class="w"></span>

<span class="c1">//对64位和32位架构，读取time的方法是不同的</span>
<span class="c1">//32位架构下，需要把64位的time寄存器读到两个32位整数里，然后拼起来形成一个64位整数</span>
<span class="c1">//64位架构简单的一句rdtime就可以了</span>
<span class="c1">//__riscv_xlen是gcc定义的一个宏，可以用来区分是32位还是64位。</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">get_time</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="c1">//返回当前时间</span>
<span class="cp">#if __riscv_xlen == 64</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;rdtime %0&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">n</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lo</span><span class="p">,</span><span class="w"> </span><span class="n">hi</span><span class="p">,</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="n">__volatile__</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;1:</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;rdtimeh %0</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;rdtime %1</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;rdtimeh %2</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;bne %0, %2, 1b&quot;</span><span class="w"></span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;=&amp;r&quot;</span><span class="p">(</span><span class="n">hi</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;=&amp;r&quot;</span><span class="p">(</span><span class="n">lo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;=&amp;r&quot;</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">hi</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">lo</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="p">}</span><span class="w"></span>


<span class="c1">// Hardcode timebase</span>
<span class="k">static</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">timebase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100000</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">clock_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// sie这个CSR可以单独使能/禁用某个来源的中断。默认时钟中断是关闭的</span>
<span class="w">    </span><span class="c1">// 所以我们要在初始化的时候，使能时钟中断</span>
<span class="w">    </span><span class="n">set_csr</span><span class="p">(</span><span class="n">sie</span><span class="p">,</span><span class="w"> </span><span class="n">MIP_STIP</span><span class="p">);</span><span class="w"> </span><span class="c1">// enable timer interrupt in sie</span>
<span class="w">    </span><span class="c1">//设置第一个时钟中断事件</span>
<span class="w">    </span><span class="n">clock_set_next_event</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 初始化一个计数器</span>
<span class="w">    </span><span class="n">ticks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cprintf</span><span class="p">(</span><span class="s">&quot;++ setup timer interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">//设置时钟中断：timer的数值变为当前时间 + timebase 后，触发一次时钟中断</span>
<span class="c1">//对于QEMU, timer增加1，过去了10^-7 s， 也就是100ns</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">clock_set_next_event</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sbi_set_timer</span><span class="p">(</span><span class="n">get_time</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">timebase</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>回来看trap.c里面时钟中断处理的代码, 还是很简单的：每秒100次时钟中断，触发每次时钟中断后设置10ms后触发下一次时钟中断，每触发100次时钟中断（1秒钟）输出一行信息到控制台。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// kern/trap/trap.c</span>
<span class="cp">#include</span><span class="cpf">&lt;clock.h&gt;</span><span class="cp"></span>

<span class="cp">#define TICK_NUM 100</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print_ticks</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cprintf</span><span class="p">(</span><span class="s">&quot;%d ticks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TICK_NUM</span><span class="p">);</span><span class="w"></span>
<span class="cp">#ifdef DEBUG_GRADE</span>
<span class="w">    </span><span class="n">cprintf</span><span class="p">(</span><span class="s">&quot;End of Test.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">&quot;EOT: kernel seems ok.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">interrupt_handler</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">trapframe</span><span class="w"> </span><span class="o">*</span><span class="n">tf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">intptr_t</span><span class="w"> </span><span class="n">cause</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">cause</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">cause</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       	</span><span class="cm">/* blabla 其他case*/</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nl">IRQ_S_TIMER</span><span class="p">:</span><span class="w"></span>
<span class="w">            </span><span class="n">clock_set_next_event</span><span class="p">();</span><span class="c1">//发生这次时钟中断的时候，我们要设置下一次时钟中断</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">ticks</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">TICK_NUM</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">print_ticks</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* blabla 其他case*/</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>现在执行<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">qemu</span></code>, 应该能看到打印一行行的<code class="docutils literal notranslate"><span class="pre">100</span> <span class="pre">ticks</span></code></p>
<p>目前为止的代码可以在<a class="reference external" href="https://github.com/Liurunda/riscv64-ucore/tree/lab1/lab1">这里</a>找到，遇到困难可以参考。</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="lab1_3_3_trap.html" class="btn btn-neutral float-left" title="中断处理程序" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="../lab1-4/lab1_4_lab_requirement.html" class="btn btn-neutral float-right" title="实验报告要求" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2023, NKU.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>