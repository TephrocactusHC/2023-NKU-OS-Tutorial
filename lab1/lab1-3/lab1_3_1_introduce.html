<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>riscv64 中断介绍 &mdash; 2023级NKU操作系统实验指导书 1.1.0 文档</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=ab4a11d3"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/translations.js?v=beaddf03"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="掉进兔子洞(中断入口点)" href="lab1_3_2_trapentry.html" />
    <link rel="prev" title="中断与中断处理流程" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            2023级NKU操作系统实验指导书
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../README/README.html">欢迎来到ucore step-by-step的世界</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab0/index.html">lab0: 预备起</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab0.5/index.html">lab0.5: 比麻雀更小的麻雀(最小可执行内核)</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">lab1: 断, 都可以断</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#id1">本章内容</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../lab1-1/lab1_1_goals.html">实验目的：</a></li>
<li class="toctree-l3"><a class="reference internal" href="../lab1-2/index.html">实验目的</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">中断与中断处理流程</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="index.html#id2">本节内容</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../lab1-4/lab1_4_lab_requirement.html">实验报告要求</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../lab2/index.html">lab2:物理内存和页表</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab3/index.html">lab3:缺页异常和页面置换</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab4/index.html">lab4:进程管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab5/index.html">lab5:用户程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab6/index.html">lab6 进程调度</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab7/index.html">lab7 同步互斥</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab8/index.html">Lab8 文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../appendix/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">2023级NKU操作系统实验指导书</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">lab1: 断, 都可以断</a></li>
          <li class="breadcrumb-item"><a href="index.html">中断与中断处理流程</a></li>
      <li class="breadcrumb-item active">riscv64 中断介绍</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/lab1/lab1-3/lab1_3_1_introduce.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="riscv64">
<h1>riscv64 中断介绍<a class="headerlink" href="#riscv64" title="Link to this heading"></a></h1>
<section id="id1">
<h2>中断概念<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<section id="id2">
<h3>中断机制<a class="headerlink" href="#id2" title="Link to this heading"></a></h3>
<p><strong>中断</strong>（interrupt）机制，就是不管CPU现在手里在干啥活，收到“中断”的时候，都先放下来去处理其他事情，处理完其他事情可能再回来干手头的活。</p>
<p>例如，CPU要向磁盘发一个读取数据的请求，由于磁盘速度相对CPU较慢，在“发出请求”到“收到磁盘数据”之间会经过很多时间周期，如果CPU干等着磁盘干活就相当于CPU在磨洋工。因此我们可以让CPU发出读数据的请求后立刻开始干另一件事情。但是，等一段时间之后，磁盘的数据取到了，而CPU在干其他的事情，我们怎么办才能让CPU知道之前发出的磁盘请求已经完成了呢？我们可以让磁盘给CPU一个“中断”，让CPU放下手里的事情来接受磁盘的数据。</p>
<p>再比如，为了保证CPU正在执行的程序不会永远运行下去，我们需要定时检查一下它是否已经运行“超时”。想象有一个程序由于bug进入了死循环，如果CPU一直运行这个程序，那么其他的所有程序都会因为等待CPU资源而无法运行，造成严重的资源浪费。但是检查是否超时，需要CPU执行一段代码，也就是让CPU暂停当前执行的程序。我们不能假设当前执行的程序会主动地定时让出CPU，那么就需要CPU定时“打断”当前程序的执行，去进行一些处理，这通过时钟中断来实现。</p>
<p>从这些描述我们可以看出，中断机制需要软件硬件一起来支持。硬件进行中断和异常的发现，然后交给软件来进行处理。回忆一下组成原理课程中学到的各个控制寄存器以及他们的用途（下一小节会进行简单回顾），这些寄存器构成了重要的<strong>硬件/软件接口</strong>。由此，我们也可以得到在一般OS中进行中断处理支持的方法：</p>
<ul class="simple">
<li><p>编写相应的中断处理代码</p></li>
<li><p>在启动中正确设置控制寄存器</p></li>
<li><p>CPU捕获异常</p></li>
<li><p>控制转交给相应中断处理代码进行处理</p></li>
<li><p>返回正在运行的程序</p></li>
</ul>
</section>
<section id="id3">
<h3><strong>中断分类</strong><a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<p>异常(Exception)，指在执行一条指令的过程中发生了错误，此时我们通过中断来处理错误。最常见的异常包括：访问无效内存地址、执行非法指令(除零)、发生缺页等。他们有的可以恢复(如缺页)，有的不可恢复(如除零)，只能终止程序执行。</p>
<p>陷入(Trap)，指我们主动通过一条指令停下来，并跳转到处理函数。常见的形式有通过ecall进行系统调用(syscall)，或通过ebreak进入断点(breakpoint)。</p>
<p>外部中断(Interrupt)，简称中断，指的是 CPU 的执行过程被外设发来的信号打断，此时我们必须先停下来对该外设进行处理。典型的有定时器倒计时结束、串口收到数据等。</p>
<p>外部中断是异步(asynchronous)的，CPU 并不知道外部中断将何时发生。CPU 也并不需要一直在原地等着外部中断的发生，而是执行代码，有了外部中断才去处理。我们知道，CPU 的主频远高于 I/O 设备，这样避免了 CPU 资源的浪费。</p>
<p>由于中断处理需要进行较高权限的操作，中断处理程序一般处于<strong>内核态</strong>，或者说，处于“比被打断的程序更高的特权级”。注意，在RISCV里，中断(interrupt)和异常(exception)统称为”trap”。</p>
<blockquote>
<div><p>扩展</p>
<p>The RISC-V Instruction Set Manual Volume I: Unprivileged ISA （Document Version 20191213）</p>
<p>1.6</p>
<p>We use the term <strong>exception</strong> to refer to an unusual condition occurring at run time associated with an instruction in the current RISC-V hart.</p>
<p>We use the term <strong>interrupt</strong> to refer to an external asynchronous event that may cause a RISC-V hart to experience an unexpected transfer of control.
We use the term <strong>trap</strong> to refer to the transfer of control to a trap handler caused by either an
exception or an interrupt.</p>
</div></blockquote>
</section>
</section>
<section id="id4">
<h2>riscv64 权限模式<a class="headerlink" href="#id4" title="Link to this heading"></a></h2>
<section id="riscv64-m-mode">
<h3>riscv64 的 M Mode<a class="headerlink" href="#riscv64-m-mode" title="Link to this heading"></a></h3>
<p>M-mode(机器模式，缩写为 M 模式)是 RISC-V 中 hart(hardware thread,硬件线程)可以执行的最高权限模式。在 M 模式下运行的 hart 对内存,I/O 和一些对于启动和配置系统来说必要的底层功能有着完全的使用权。默认情况下,发生所有异常(不论在什么权限模式下)的时候,控制权都会被移交到 M 模式的异常处理程序。它是唯一所有标准 RISC-V 处理器都必须实现的权限模式。</p>
</section>
<section id="riscv64-s-mode">
<h3>riscv64 的 S Mode<a class="headerlink" href="#riscv64-s-mode" title="Link to this heading"></a></h3>
<p>S-mode(监管者模式，缩写为 S 模式)是支持现代类 Unix 操作系统的权限模式，支持基于页面的虚拟内存机制是其核心。 Unix 系统中的大多数例外都应该进行 S 模式下的系统调用。M 模式的异常处理程序可以将异常重新导向 S 模式，也支持通过异常委托机制（Machine Interrupt Delegation,机器中断委托）选择性地将中断和同步异常直接交给 S 模式处理,而完全绕过 M 模式。</p>
</section>
</section>
<section id="id5">
<h2>寄存器<a class="headerlink" href="#id5" title="Link to this heading"></a></h2>
<p>除了32个通用寄存器之外，RISCV架构还有大量的 <strong>控制状态寄存器</strong> <strong>Control and Status Registers</strong>(CSRs)。其中有几个重要的寄存器和中断机制有关。</p>
<p>有些时候，禁止CPU产生中断很有用。（就像你在做重要的事情，如操作系统lab的时候，并不想被打断）。所以，<code class="docutils literal notranslate"><span class="pre">sstatus</span></code>寄存器(Supervisor Status Register)里面有一个二进制位<code class="docutils literal notranslate"><span class="pre">SIE</span></code>(supervisor interrupt enable，在RISCV标准里是2^1 对应的二进制位)，数值为0的时候，如果当程序在S态运行，将禁用全部中断。（对于在U态运行的程序，SIE这个二进制位的数值没有任何意义），<code class="docutils literal notranslate"><span class="pre">sstatus</span></code>还有一个二进制位<code class="docutils literal notranslate"><span class="pre">UIE</span></code>(user interrupt enable)可以在置零的时候禁止用户态程序产生中断。</p>
<p>在中断产生后，应该有个<strong>中断处理程序</strong>来处理中断。CPU怎么知道中断处理程序在哪？实际上，RISCV架构有个CSR叫做<code class="docutils literal notranslate"><span class="pre">stvec</span></code>(Supervisor Trap Vector Base Address Register)，即所谓的”中断向量表基址”。中断向量表的作用就是把不同种类的中断映射到对应的中断处理程序。如果只有一个中断处理程序，那么可以让<code class="docutils literal notranslate"><span class="pre">stvec</span></code>直接指向那个中断处理程序的地址。</p>
<p>对于RISCV架构，<code class="docutils literal notranslate"><span class="pre">stvec</span></code>会把最低位的两个二进制位用来编码一个“模式”，如果是“00”就说明更高的SXLEN-2个二进制位存储的是唯一的中断处理程序的地址(SXLEN是<code class="docutils literal notranslate"><span class="pre">stval</span></code>寄存器的位数)，如果是“01”说明更高的SXLEN-2个二进制位存储的是中断向量表基址，通过不同的异常原因来索引中断向量表。但是怎样用62个二进制位编码一个64位的地址？RISCV架构要求这个地址是四字节对齐的，总是在较高的62位后补两个0。</p>
<blockquote>
<div><p>​	扩展</p>
<p>在旧版本的RISCV privileged ISA标准中（1.9.1及以前），RISCV不支持中断向量表，用最后两位数编码一个模式是1.10版本加入的。可以思考一下这个改动如何保证了后向兼容。<a class="reference external" href="https://github.com/riscv/riscv-isa-manual/releases/tag/archive">历史版本的ISA手册</a></p>
<p>1.9.1版本的RISCV privileged architecture手册：</p>
<p>4.1.3 Supervisor Trap Vector Base Address Register (stvec) The stvec register is an XLEN-bit read/write register that holds the base address of the S-mode trap vector. When an exception occurs, the pc is set to stvec. The stvec register is always aligned to a 4-byte boundary</p>
</div></blockquote>
<p>当我们触发中断进入 S 态进行处理时，以下寄存器会被硬件自动设置，将一些信息提供给中断处理程序：</p>
<p><strong>sepc</strong>(supervisor exception program counter)，它会记录触发中断的那条指令的地址；</p>
<p><strong>scause</strong>，它会记录中断发生的原因，还会记录该中断是不是一个外部中断；</p>
<p><strong>stval</strong>，它会记录一些中断处理所需要的辅助信息，比如指令获取(instruction fetch)、访存、缺页异常，它会把发生问题的目标地址或者出错的指令记录下来，这样我们在中断处理程序中就知道处理目标了。</p>
<blockquote>
<div><p>扩展</p>
<p>The RISC-V Instruction Set Manual Volume II: Privileged Architecture</p>
<p>（Document Version 20190608-Priv-MSU-Ratified）</p>
<p>4.1.1 Supervisor Status Register (sstatus)</p>
<p>The SIE bit enables or disables all interrupts in supervisor mode. When SIE is clear, interrupts
are not taken while in supervisor mode. When the hart is running in user-mode, the value in
SIE is ignored, and supervisor-level interrupts are enabled. The supervisor can disable individual
interrupt sources using the sie CSR.
The SPIE bit indicates whether supervisor interrupts were enabled prior to trapping into supervisor
mode. When a trap is taken into supervisor mode, SPIE is set to SIE, and SIE is set to 0. When
an SRET instruction is executed, SIE is set to SPIE, then SPIE is set to 1.
The UIE bit enables or disables user-mode interrupts. User-level interrupts are enabled only if UIE
is set and the hart is running in user-mode. The UPIE bit indicates whether user-level interrupts
were enabled prior to taking a user-level trap. When a URET instruction is executed, UIE is set
to UPIE, and UPIE is set to 1. User-level interrupts are optional. If omitted, the UIE and UPIE
bits are hardwired to zero.</p>
<p>4.1.9 Supervisor Exception Program Counter (sepc)</p>
<p>When a trap is taken into S-mode, sepc is written with the virtual address of the instruction
that was interrupted or that encountered the exception. Otherwise, sepc is never written by the
implementation, though it may be explicitly written by software.</p>
<p>4.1.10 Supervisor Cause Register (scause)</p>
<p>When a trap is taken into S-mode, scause is written with a code indicating the event that caused the trap. Otherwise, scause is never written by the implementation, though it may be explicitly written by
software.</p>
<p>4.1.11 Supervisor Trap Value (stval) Register</p>
<p>When a trap is taken into S-mode, stval is written with exception-specific information to assist software
in handling the trap. Otherwise, stval is never written by the implementation, though it may
be explicitly written by software. The hardware platform will specify which exceptions must set
stval informatively and which may unconditionally set it to zero.
When a hardware breakpoint is triggered, or an instruction-fetch, load, or store address-misaligned,
access, or page-fault exception occurs, stval is written with the faulting virtual address. On an
illegal instruction trap, stval may be written with the first XLEN or ILEN bits of the faulting
instruction as described below. For other exceptions, stval is set to zero, but a future standard
may redefine stval’s setting for other exceptions.</p>
</div></blockquote>
</section>
<section id="id6">
<h2>特权指令<a class="headerlink" href="#id6" title="Link to this heading"></a></h2>
<p>RISCV支持以下和中断相关的特权指令：</p>
<p><strong>ecall</strong>(environment call)，当我们在 S 态执行这条指令时，会触发一个 ecall-from-s-mode-exception，从而进入 M 模式中的中断处理流程（如设置定时器等）；当我们在 U 态执行这条指令时，会触发一个 ecall-from-u-mode-exception，从而进入 S 模式中的中断处理流程（常用来进行系统调用）。</p>
<p><strong>sret</strong>，用于 S 态中断返回到 U 态，实际作用为pc←sepc，回顾<strong>sepc</strong>定义，返回到通过中断进入 S 态之前的地址。</p>
<p><strong>ebreak</strong>(environment break)，执行这条指令会触发一个断点中断从而进入中断处理流程。</p>
<p><strong>mret</strong>，用于 M 态中断返回到 S 态或 U 态，实际作用为pc←mepc，回顾<strong>sepc</strong>定义，返回到通过中断进入 M 态之前的地址。（一般不用涉及）</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="index.html" class="btn btn-neutral float-left" title="中断与中断处理流程" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="lab1_3_2_trapentry.html" class="btn btn-neutral float-right" title="掉进兔子洞(中断入口点)" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2023, NKU OS LAB.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>