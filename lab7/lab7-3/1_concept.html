<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>同步互斥的一些基本概念 &mdash; 2023级NKU操作系统实验指导书 1.0.0 文档</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/translations.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="信号量" href="../lab7-4/2_semaphore.html" />
    <link rel="prev" title="项目组成" href="../lab7-2/structure.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            2023级NKU操作系统实验指导书
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../README/README.html">欢迎来到ucore step-by-step的世界</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab0/index.html">lab0: 预备起</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab0.5/index.html">lab0.5: 比麻雀更小的麻雀(最小可执行内核)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab1/index.html">lab1: 断, 都可以断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab2/index.html">lab2:物理内存和页表</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab3/index.html">lab3:缺页异常和页面置换</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab4/index.html">lab4:进程管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab5/index.html">lab5:用户程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab6/index.html">lab6 进程调度</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">lab7 同步互斥</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#id1">本章内容</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../lab7-1/goals.html">实验目的</a></li>
<li class="toctree-l3"><a class="reference internal" href="../lab7-2/index.html">实验内容</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">同步互斥的一些基本概念</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">时钟中断管理</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">屏蔽使能中断</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">等待队列：</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../lab7-4/2_semaphore.html">信号量</a></li>
<li class="toctree-l3"><a class="reference internal" href="../lab7-5/3_monitor.html">管程</a></li>
<li class="toctree-l3"><a class="reference internal" href="../lab7-6/appendix.html">附录：执行<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">qemu</span></code>的大致输出</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../lab8/index.html">Lab8 文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../appendix/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">2023级NKU操作系统实验指导书</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">lab7 同步互斥</a></li>
      <li class="breadcrumb-item active">同步互斥的一些基本概念</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/lab7/lab7-3/1_concept.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>同步互斥的一些基本概念<a class="headerlink" href="#id1" title="永久链接至标题"></a></h1>
<p>虽然我们经常把同步和互斥放在一起说，但是这两个词是两个概念。<strong>同步</strong>指的是进程间的执行需要按照某种先后顺序，即访问是有序的。<strong>互斥</strong>指的是对于某些共享资源的访问不能同时进行，同一时间只能有一定数量的进程进行。这两种情况基本构成了我们在多线程执行中遇到的各种问题。</p>
<p>与同步互斥相关的另一个概念是<strong>临界区</strong>。临界区指的是进程的一段代码，其特征要求了同一时间段只能有一个进程执行，否则就有可能出现问题。一般而言，进程处理临界区的思路是设计一个协议，不同的进程遵守这个相同的协议来进行临界区的协调。在进入临界区前，进程请求进入的许可，这段代码称为<strong>进入区</strong>；退出临界区时，进程应该通过协议告知别的进程自己已经使用完临界区，这段代码称为<strong>退出区</strong>；临界区其他的部分称为<strong>剩余区</strong>。我们本章解决的问题，就是在进入区和退出区为进程提供同步互斥的机制。</p>
<p>为了提供同步互斥机制，操作系统有多种实现方法，包括时钟中断管理，屏蔽使能中断，等待队列，信号量，管程等等。下面我们来分别看一看上面提到的部分机制：</p>
<section id="id2">
<h2>时钟中断管理<a class="headerlink" href="#id2" title="永久链接至标题"></a></h2>
<p>在lab1中我们已经实现了时钟中断。在ucore 中，时钟（timer）中断给操作系统提供了有一定间隔的时间事件，操作系统将其作为基本的调度和计时单位（我们记两次时间中断之间的时间间隔为一个时间片，timer splice）。</p>
<p>通过时钟中断，操作系统可以提供基于时间节点的事件。通过时钟中断，操作系统可以提供任意长度的等待唤醒机制，由此可以给应用程序机会来实现更加复杂的自定义调度操作。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sched.h</span></code>, <code class="docutils literal notranslate"><span class="pre">sched.c</span></code> 定义了有关timer的各种相关接口来使用 timer 服务，其中主要包括:</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">struct</span> <span class="pre">{……}</span> <span class="pre">timer_t</span></code>: 定义了 timer_t 的基本结构，其可以用 <code class="docutils literal notranslate"><span class="pre">sched.h</span></code> 中的<code class="docutils literal notranslate"><span class="pre">timer_init</span></code>函数对其进行初始化。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">timer_init(timer</span> <span class="pre">t</span> <span class="pre">*timer,</span> <span class="pre">struct</span> <span class="pre">proc_struct</span> <span class="pre">*proc,</span> <span class="pre">int</span> <span class="pre">expires)</span></code>: 对某timer进行初始化，让它在 expires 时间片之后唤醒 proc进程。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">add_timer(timer</span> <span class="pre">t</span> <span class="pre">*timer)</span></code>: 向系统添加某个初始化过的timer_t，该timer在指定时间后被激活，并将对应的进程唤醒至runnable（如果当前进程处在等待状态）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">del_timer(timer_t</span> <span class="pre">*time)</span></code>: 向系统删除（或者说取消）某一个timer。该timer在取消后不会被系统激活并唤醒进程。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">run_timer_list(void)</span></code>: 更新当前系统时间点，遍历当前所有处在系统管理内的timer，找出所有应该激活的计数器，并激活它们。该过程在且只在每次时钟中断时被调用。在ucore中，其还会调用调度器事件处理程序。</p></li>
</ul>
<p>一个 timer_t 在系统中的存活周期可以被描述如下：</p>
<ol class="simple">
<li><p>timer_t 在某个位置被创建和初始化，并通过add_timer加入系统管理列表中。</p></li>
<li><p>系统时间被不断累加，直到 run_timer_list 发现该 timer_t到期。</p></li>
<li><p>run_timer_list更改对应的进程状态，并从系统管理列表中移除该timer_t。</p></li>
</ol>
<p>尽管本次实验并不需要填充时钟相关的代码，但是作为系统重要的组件，你应该了解其相关机制和在ucore中的实现方法和使用方法。且在trap_dispatch函数中修改之前对时钟中断的处理，使得ucore能够利用时钟提供的功能完成调度和睡眠唤醒等操作。</p>
</section>
<section id="id3">
<h2>屏蔽使能中断<a class="headerlink" href="#id3" title="永久链接至标题"></a></h2>
<p>这部分主要是处理内核内的同步互斥问题。因为内核在执行的过程中可能会被外部的中断打断，我们实现的ucore也是不可抢占的系统，所以可以在操作系统进行某些需要同步互斥的操作的时候先禁用中断，等执行完之后再使能。这样保证了操作系统在执行临界区的时候不会被打断，也就实现了同步互斥。</p>
<p>根据操作系统原理的知识，我们知道如果没有在硬件级保证读内存-修改值-写回内存的原子性，我们只能通过复杂的软件来实现同步互斥操作。但由于有开关中断和test_and_set_bit等原子操作机器指令的存在，使得我们在实现同步互斥原语上可以大大简化。</p>
<p>在ucore中提供的底层机制包括中断屏蔽/使能控制等。kern/sync.c中实现的开关中断的控制函数local_intr_save(x)和local_intr_restore(x)，它们是基于kern/driver文件下的intr_enable()、intr_disable()函数实现的。具体调用关系为：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>关中断：local_intr_save --&gt; __intr_save --&gt; intr_disable --&gt; cli
开中断：local_intr_restore--&gt; __intr_restore --&gt; intr_enable --&gt; sti 
</pre></div>
</div>
<p>最终的cli和sti是x86的机器指令，最终实现了关（屏蔽）中断和开（使能）中断，即设置了eflags寄存器中与中断相关的位。通过关闭中断，可以防止对当前执行的控制流被其他中断事件处理所打断。既然不能中断，那也就意味着在内核运行的当前进程无法被打断或被重新调度，即实现了对临界区的互斥操作。所以在单处理器情况下，可以通过开关中断实现对临界区的互斥保护，需要互斥的临界区代码的一般写法为：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>local_intr_save(intr_flag);
{
  临界区代码
}
local_intr_restore(intr_flag);
……
</pre></div>
</div>
<p>由于目前ucore只实现了对单处理器的支持，所以通过这种方式，就可简单地支撑互斥操作了。在多处理器情况下，这种方法是无法实现互斥的，因为屏蔽了一个CPU的中断，只能阻止本地CPU上的进程不会被中断或调度，并不意味着其他CPU上执行的进程不能执行临界区的代码。所以，开关中断只对单处理器下的互斥操作起作用。在本实验中，开关中断机制是实现信号量等高层同步互斥原语的底层支撑基础之一。</p>
</section>
<section id="id4">
<h2>等待队列：<a class="headerlink" href="#id4" title="永久链接至标题"></a></h2>
<p>等待队列是操作系统提供的一种事件机制。一些进程可能会在执行的过程中等待某些特定事件的发生，这个时候进程进入睡眠状态。操作系统维护一个等待队列，把这个进程放进他等待的事件的等待队列中。当对应的事件发生之后，操作系统就唤醒相应等待队列中的进程。这也是ucore内部实现信号量的机制。</p>
<p>内核实现这一功能的一个底层支撑机制就是等待队列<code class="docutils literal notranslate"><span class="pre">wait_queue</span></code>，等待队列和每一个事件（睡眠结束、时钟到达、任务完成、资源可用等）联系起来。需要等待事件的进程在转入休眠状态后插入到等待队列中。当事件发生之后，内核遍历相应等待队列，唤醒休眠的用户进程或内核线程，并设置其状态为就绪状态（PROC_RUNNABLE），并将该进程从等待队列中清除。ucore在<code class="docutils literal notranslate"><span class="pre">kern/sync/{</span> <span class="pre">wait.h,</span> <span class="pre">wait.c}</span></code>中实现了等待项wait结构和等待队列<code class="docutils literal notranslate"><span class="pre">wait_queue</span></code>结构以及相关函数），这是实现ucore中的信号量机制和条件变量机制的基础，进入wait
queue的进程会被设为等待状态（PROC_SLEEPING），直到他们被唤醒。</p>
<p>####　数据结构定义</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc_struct</span><span class="w"> </span><span class="o">*</span><span class="n">proc</span><span class="p">;</span><span class="w">     </span><span class="c1">//等待进程的指针</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">wakeup_flags</span><span class="p">;</span><span class="w">        </span><span class="c1">//进程被放入等待队列的原因标记</span>
<span class="w">    </span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">wait_queue</span><span class="p">;</span><span class="w">     </span><span class="c1">//指向此wait结构所属于的wait_queue</span>
<span class="w">    </span><span class="n">list_entry_t</span><span class="w"> </span><span class="n">wait_link</span><span class="p">;</span><span class="w">       </span><span class="c1">//用来组织wait_queue中wait节点的连接</span>
<span class="p">}</span><span class="w"> </span><span class="n">wait_t</span><span class="p">;</span><span class="w"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">list_entry_t</span><span class="w"> </span><span class="n">wait_head</span><span class="p">;</span><span class="w">       </span><span class="c1">//wait_queue的队头</span>
<span class="p">}</span><span class="w"> </span><span class="n">wait_queue_t</span><span class="p">;</span><span class="w"></span>

<span class="n">le2wait</span><span class="p">(</span><span class="n">le</span><span class="p">,</span><span class="w"> </span><span class="n">member</span><span class="p">)</span><span class="w">               </span><span class="c1">//实现wait_t中成员的指针向wait_t 指针的转化</span>
</pre></div>
</div>
<p>####　相关函数说明
与wait和wait queue相关的函数主要分为两层，底层函数是对wait queue的初始化、插入、删除和查找操作，相关函数如下：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">wait_init</span><span class="p">(</span><span class="n">wait_t</span><span class="w"> </span><span class="o">*</span><span class="n">wait</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc_struct</span><span class="w"> </span><span class="o">*</span><span class="n">proc</span><span class="p">);</span><span class="w">    </span><span class="c1">//初始化wait结构</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">wait_in_queue</span><span class="p">(</span><span class="n">wait_t</span><span class="w"> </span><span class="o">*</span><span class="n">wait</span><span class="p">);</span><span class="w">                          </span><span class="c1">//wait是否在wait queue中</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">wait_queue_init</span><span class="p">(</span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">queue</span><span class="p">);</span><span class="w">                 </span><span class="c1">//初始化wait_queue结构</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">wait_queue_add</span><span class="p">(</span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="n">wait_t</span><span class="w"> </span><span class="o">*</span><span class="n">wait</span><span class="p">);</span><span class="w">    </span><span class="c1">//把wait前插到wait queue中</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">wait_queue_del</span><span class="p">(</span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="n">wait_t</span><span class="w"> </span><span class="o">*</span><span class="n">wait</span><span class="p">);</span><span class="w">    </span><span class="c1">//从wait queue中删除wait</span>
<span class="n">wait_t</span><span class="w"> </span><span class="o">*</span><span class="nf">wait_queue_next</span><span class="p">(</span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="n">wait_t</span><span class="w"> </span><span class="o">*</span><span class="n">wait</span><span class="p">);</span><span class="c1">//取得wait的后一个链接指针</span>
<span class="n">wait_t</span><span class="w"> </span><span class="o">*</span><span class="nf">wait_queue_prev</span><span class="p">(</span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="n">wait_t</span><span class="w"> </span><span class="o">*</span><span class="n">wait</span><span class="p">);</span><span class="c1">//取得wait的前一个链接指针</span>
<span class="n">wait_t</span><span class="w"> </span><span class="o">*</span><span class="nf">wait_queue_first</span><span class="p">(</span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">queue</span><span class="p">);</span><span class="w">             </span><span class="c1">//取得wait queue的第一个wait</span>
<span class="n">wait_t</span><span class="w"> </span><span class="o">*</span><span class="nf">wait_queue_last</span><span class="p">(</span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">queue</span><span class="p">);</span><span class="w">              </span><span class="c1">//取得wait queue的最后一个wait</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">wait_queue_empty</span><span class="p">(</span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">queue</span><span class="p">);</span><span class="w">                </span><span class="c1">//wait queue是否为空</span>
</pre></div>
</div>
<p>高层函数基于底层函数实现了让进程进入等待队列<code class="docutils literal notranslate"><span class="pre">wait_current_set</span></code>，以及从等待队列中唤醒进程<code class="docutils literal notranslate"><span class="pre">wakeup_wait</span></code>，相关函数如下：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">//让wait与进程关联，且让当前进程关联的wait进入等待队列queue，当前进程睡眠</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">wait_current_set</span><span class="p">(</span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="n">wait_t</span><span class="w"> </span><span class="o">*</span><span class="n">wait</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">wait_state</span><span class="p">);</span><span class="w"></span>
<span class="c1">//把与当前进程关联的wait从等待队列queue中删除</span>
<span class="n">wait_current_del</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="n">wait</span><span class="p">);</span><span class="w"></span>
<span class="c1">//唤醒与wait关联的进程</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">wakeup_wait</span><span class="p">(</span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="n">wait_t</span><span class="w"> </span><span class="o">*</span><span class="n">wait</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">wakeup_flags</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">del</span><span class="p">);</span><span class="w"></span>
<span class="c1">//唤醒等待队列上挂着的第一个wait所关联的进程</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">wakeup_first</span><span class="p">(</span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">wakeup_flags</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">del</span><span class="p">);</span><span class="w"></span>
<span class="c1">//唤醒等待队列上所有的等待的进程</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">wakeup_queue</span><span class="p">(</span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">wakeup_flags</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">del</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<section id="id5">
<h3>调用关系举例<a class="headerlink" href="#id5" title="永久链接至标题"></a></h3>
<p>如下图所示，对于唤醒进程的函数<code class="docutils literal notranslate"><span class="pre">wakeup_wait</span></code>，可以看到它会被各种信号量的V操作函数<code class="docutils literal notranslate"><span class="pre">up</span></code>调用，并且它会调用<code class="docutils literal notranslate"><span class="pre">wait_queue_del</span></code>函数和<code class="docutils literal notranslate"><span class="pre">wakup_proc</span></code>函数来完成唤醒进程的操作。
<img alt="image" src="../../_images/1.png" /></p>
<p>如下图所示，而对于让进程进入等待状态的函数<code class="docutils literal notranslate"><span class="pre">wait_current_set</span></code>，可以看到它会被各种信号量的P操作函数<code class="docutils literal notranslate"><span class="pre">down</span></code>调用，并且它会调用<code class="docutils literal notranslate"><span class="pre">wait_init</span></code>完成对等待项的初始化，并进一步调用<code class="docutils literal notranslate"><span class="pre">wait_queue_add</span></code>来把与要处于等待状态的进程所关联的等待项挂到与信号量绑定的等待队列中。
<img alt="image" src="../../_images/2.png" /></p>
<p>接下来的两节，我们来仔细看一看信号量和管程的实现。</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="../lab7-2/structure.html" class="btn btn-neutral float-left" title="项目组成" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="../lab7-4/2_semaphore.html" class="btn btn-neutral float-right" title="信号量" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2023, NKU.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>