<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>实现分页机制 &mdash; 2023级NKU操作系统实验指导书 1.0.0 文档</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/translations.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" />
    <link rel="next" title="物理内存管理的设计思路" href="../lab2_3_6/index.html" />
    <link rel="prev" title="建立段页式管理中需要考虑的关键问题" href="lab2_3_5_1_key_problems_in_seg_page.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            2023级NKU操作系统实验指导书
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../README/README.html">欢迎来到ucore step-by-step的世界</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab0/index.html">lab0: 预备起</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab0.5/index.html">lab0.5: 比麻雀更小的麻雀(最小可执行内核)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab1/index.html">lab1: 断, 都可以断</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">lab2:物理内存和页表</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../index.html#id1">本章内容</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../lab2-1/lab2_1_goal.html">实验目的</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../lab2-2/index.html">实验内容</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">物理内存管理</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="../index.html#id2">本节内容</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../lab2-4/lab2_4_labs_requirement.html">实验报告要求</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab3/index.html">lab3:缺页异常和页面置换</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab4/index.html">lab4:进程管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab5/index.html">lab5:用户程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab6/index.html">lab6 进程调度</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab7/index.html">lab7 同步互斥</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab8/index.html">Lab8 文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../appendix/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">2023级NKU操作系统实验指导书</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">lab2:物理内存和页表</a></li>
          <li class="breadcrumb-item"><a href="../index.html">物理内存管理</a></li>
          <li class="breadcrumb-item"><a href="index.html">分页机制的设计思路</a></li>
      <li class="breadcrumb-item active">实现分页机制</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/lab2/lab2-3/lab2_3_5/lab2_3_5_2_kernel_initialization.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>实现分页机制<a class="headerlink" href="#id1" title="永久链接至标题"></a></h1>
<p>在本实验中，需要重点了解和实现基于页表的页机制和以页为单位的物理内存管理方法和分配算法等。由于ucore OS是基于80386 CPU实现的，所以CPU在进入保护模式后，就直接使能了段机制，并使得ucore OS需要在段机制的基础上建立页机制。下面比较详细地介绍了实现分页机制的过程。</p>
<p>接下来我们就正式开始实验啦！
首先我们要做的是内核初始化的修改，我们现在需要做的就是把原本只能直接在物理地址空间上运行的内核引入页表机制。
具体来说，我们现在想将内核代码放在虚拟地址空间中以 <code class="docutils literal notranslate"><span class="pre">0xffffffffc0200000</span></code> 开头的一段高地址空间中。那怎么做呢？首先我们需要将下面的参数修改一下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">tools</span><span class="o">/</span><span class="n">kernel</span><span class="o">.</span><span class="n">ld</span>
<span class="n">BASE_ADDRESS</span> <span class="o">=</span> <span class="mh">0xFFFFFFFFC0200000</span><span class="p">;</span>
<span class="o">//</span><span class="n">之前这里是</span> <span class="mh">0x80200000</span>
</pre></div>
</div>
<p>我们修改了链接脚本中的起始地址。但是这样做的话，就能从物理地址空间转移到虚拟地址空间了吗？大家可以分析一下现在我们相当于是在 bootloader 的 OpenSBI 结束后的现状，这样就可以更好的理解接下来我们需要干什么：</p>
<ul class="simple">
<li><p>物理内存状态：OpenSBI 代码放在 <code class="docutils literal notranslate"><span class="pre">[0x80000000,0x80200000)</span></code> 中，内核代码放在以 <code class="docutils literal notranslate"><span class="pre">0x80200000</span></code> 开头的一块连续物理内存中。这个是实验一我们做完后就实现的效果。</p></li>
<li><p>CPU 状态：处于 S Mode ，寄存器 <code class="docutils literal notranslate"><span class="pre">satp</span></code> 的 <code class="docutils literal notranslate"><span class="pre">MODE</span></code>被设置为 <code class="docutils literal notranslate"><span class="pre">Bare</span></code> ，即无论取指还是访存我们都通过物理地址直接访问物理内存。 <code class="docutils literal notranslate"><span class="pre">PC=0x80200000</span></code> 指向内核的第一条指令。栈顶地址 <code class="docutils literal notranslate"><span class="pre">SP</span></code> 处在 OpenSBI 代码内。</p></li>
<li><p>内核代码：这部分由于改动了链接脚本的起始地址，所以它会认为自己处在以虚拟地址 <code class="docutils literal notranslate"><span class="pre">0xffffffffc0200000</span></code> 开头的一段连续虚拟地址空间中，以此为依据确定代码里每个部分的地址（每一段都是从<code class="docutils literal notranslate"><span class="pre">BASE_ADDRESS</span></code>往后依次摆开的，所以代码里各段都会认为自己在<code class="docutils literal notranslate"><span class="pre">0xffffffffc0200000</span></code>之后的某个地址上，或者说编译器和链接器会把里面的符号/变量地址都对应到<code class="docutils literal notranslate"><span class="pre">0xffffffffc0200000</span></code>之后的某个地址上）</p></li>
</ul>
<p>接下来，我们需要修改 <code class="docutils literal notranslate"><span class="pre">entry.S</span></code> 文件来实现内核的初始化，我们在入口点 <code class="docutils literal notranslate"><span class="pre">entry.S</span></code> 中所要做的事情是：将 <code class="docutils literal notranslate"><span class="pre">SP</span></code> 寄存器从原先指向OpenSBI 某处的栈空间，改为指向我们自己在内核的内存空间里分配的栈；同时需要跳转到函数 <code class="docutils literal notranslate"><span class="pre">kern_init</span></code> 中。</p>
<p>在之前的实验中，我们已经在 <code class="docutils literal notranslate"><span class="pre">entry.S</span></code> 自己分配了一块 <code class="docutils literal notranslate"><span class="pre">16KiB</span></code>的内存用来做启动栈：</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;mmu.h&gt;</span>
<span class="c1">#include &lt;memlayout.h&gt;</span>

<span class="w">    </span><span class="na">.section</span><span class="w"> </span><span class="no">.text</span><span class="p">,</span><span class="s">&quot;ax&quot;</span><span class="p">,</span><span class="nv">%progbits</span><span class="w"></span>
<span class="w">    </span><span class="na">.globl</span><span class="w"> </span><span class="no">kern_entry</span><span class="w"></span>
<span class="nl">kern_entry:</span><span class="w"></span>
<span class="w">    </span><span class="nf">la</span><span class="w"> </span><span class="no">sp</span><span class="p">,</span><span class="w"> </span><span class="no">bootstacktop</span><span class="w"></span>

<span class="w">    </span><span class="nf">tail</span><span class="w"> </span><span class="no">kern_init</span><span class="w"></span>

<span class="na">.section</span><span class="w"> </span><span class="no">.data</span><span class="w"></span>
<span class="w">    </span><span class="c1"># .align 2^12</span>
<span class="w">    </span><span class="na">.align</span><span class="w"> </span><span class="no">PGSHIFT</span><span class="w"></span>
<span class="w">    </span><span class="na">.global</span><span class="w"> </span><span class="no">bootstack</span><span class="w"></span>
<span class="nl">bootstack:</span><span class="w"></span>
<span class="w">    </span><span class="na">.space</span><span class="w"> </span><span class="no">KSTACKSIZE</span><span class="w"></span>
<span class="w">    </span><span class="na">.global</span><span class="w"> </span><span class="no">bootstacktop</span><span class="w"></span>
<span class="nl">bootstacktop:</span><span class="w"></span>
</pre></div>
</div>
<p>通过之前的实验大家应该都明白：符号 <code class="docutils literal notranslate"><span class="pre">bootstacktop</span></code> 就是我们需要的栈顶地址, 符号 <code class="docutils literal notranslate"><span class="pre">kern_init</span></code> 代表了我们要跳转到的地址。之前我们直接将 <code class="docutils literal notranslate"><span class="pre">bootstacktop</span></code> 的值给到 <code class="docutils literal notranslate"><span class="pre">SP</span></code> ， 再跳转到 <code class="docutils literal notranslate"><span class="pre">rust_main</span></code> 就行了。看上去上面的这个代码也能够实现我们想要的初始化效果呀？但问题在于，由于我们修改了链接脚本的起始地址，编译器和链接器认为内核开头地址为 <code class="docutils literal notranslate"><span class="pre">0xffffffffc0200000</span></code>，因此这两个符号会被翻译成比这个开头地址还要高的某个虚拟地址。而我们的 CPU 目前还处于 <code class="docutils literal notranslate"><span class="pre">Bare</span></code> 模式，会将地址都当成物理地址处理。这样，我们跳转到 <code class="docutils literal notranslate"><span class="pre">rust_main</span></code> 就会跳转到比<code class="docutils literal notranslate"><span class="pre">0xffffffffc0200000</span></code>还大的一个物理地址。但物理地址显然不可能有这么多位！这就会出现问题。</p>
<p>于是，我们需要想办法利用刚学的页表知识，帮内核将需要的虚拟地址空间构造出来。也就是：构建一个合适的页表，让<code class="docutils literal notranslate"><span class="pre">satp</span></code>指向这个页表，然后使用地址的时候都要经过这个页表的翻译，使得虚拟地址<code class="docutils literal notranslate"><span class="pre">0xFFFFFFFFC0200000</span></code>经过页表的翻译恰好变成<code class="docutils literal notranslate"><span class="pre">0x80200000</span></code>，这个地址显然就比较合适了，也就不会出错了。</p>
<p>理论知识告诉我们，所有的虚拟地址有一个固定的偏移量。而要想实现页表结构这个偏移量显然是不可或缺的。而虚拟地址和物理地址之间的差值就可以当成是这个偏移量。</p>
<p>比如内核的第一条指令，虚拟地址为 <code class="docutils literal notranslate"><span class="pre">0xffffffffc0200000</span></code> ，物理地址为 <code class="docutils literal notranslate"><span class="pre">0x80200000</span></code> ，因此，我们只要将虚拟地址减去 <code class="docutils literal notranslate"><span class="pre">0xffffffff40000000</span></code> ，就得到了物理地址。所以当我们需要做到去访问内核里面的一个物理地址 <code class="docutils literal notranslate"><span class="pre">va</span></code> 时，而已知虚拟地址为 <code class="docutils literal notranslate"><span class="pre">va</span></code> 时，则 <code class="docutils literal notranslate"><span class="pre">va</span></code> 处的代码或数据就放在物理地址为 <code class="docutils literal notranslate"><span class="pre">pa</span> <span class="pre">=</span> <span class="pre">va</span> <span class="pre">-</span> <span class="pre">0xffffffff40000000</span></code> 处的物理内存中，我们真正所要做的是要让 CPU 去访问 <code class="docutils literal notranslate"><span class="pre">pa</span></code>。因此，我们要通过恰当构造页表，来对于内核所属的虚拟地址，实现这种 <code class="docutils literal notranslate"><span class="pre">va</span></code> 到 <code class="docutils literal notranslate"><span class="pre">pa</span></code> 的映射。</p>
<p>还记得之前的理论介绍的内容吗？那时我们提到，将一个三级页表项的标志位 <code class="docutils literal notranslate"><span class="pre">R,W,X</span></code> 不设为全 <code class="docutils literal notranslate"><span class="pre">0</span></code> ，可以将它变为一个叶子，从而获得大小为 <code class="docutils literal notranslate"><span class="pre">1GiB</span></code> 的一个大页。</p>
<p>我们假定内核大小不超过 <code class="docutils literal notranslate"><span class="pre">1GiB</span></code>，通过一个大页将虚拟地址区间<code class="docutils literal notranslate"><span class="pre">[0xffffffffc0000000,0xffffffffffffffff]</span></code> 映射到物理地址区间 <code class="docutils literal notranslate"><span class="pre">[0x80000000,0xc0000000)</span></code>，而我们只需要分配一页内存用来存放三级页表，并将其最后一个页表项(也就是对应我们使用的虚拟地址区间的页表项)进行适当设置即可。对应的代码如下所示：</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span>#include &lt;mmu.h&gt;
#include &lt;memlayout.h&gt;

    .section .text,&quot;ax&quot;,%progbits
    .globl kern_entry
kern_entry:
    # t0 := 三级页表的虚拟地址
    lui     t0, %hi(boot_page_table_sv39)
    # t1 := 0xffffffff40000000 即虚实映射偏移量
    li      t1, 0xffffffffc0000000 - 0x80000000
    # t0 减去虚实映射偏移量 0xffffffff40000000，变为三级页表的物理地址
    sub     t0, t0, t1
    # t0 &gt;&gt;= 12，变为三级页表的物理页号
    srli    t0, t0, 12

    # t1 := 8 &lt;&lt; 60，设置 satp 的 MODE 字段为 Sv39
    li      t1, 8 &lt;&lt; 60
    # 将刚才计算出的预设三级页表物理页号附加到 satp 中
    or      t0, t0, t1
    # 将算出的 t0(即新的MODE|页表基址物理页号) 覆盖到 satp 中
    csrw    satp, t0
    # 使用 sfence.vma 指令刷新 TLB
    sfence.vma
    # 从此，我们给内核搭建出了一个完美的虚拟内存空间！
    #nop # 可能映射的位置有些bug。。插入一个nop
    
    # 我们在虚拟内存空间中：随意将 sp 设置为虚拟地址！
    lui sp, %hi(bootstacktop)

    # 我们在虚拟内存空间中：随意跳转到虚拟地址！
    # 跳转到 kern_init
    lui t0, %hi(kern_init)
    addi t0, t0, %lo(kern_init)
    jr t0

.section .data
    # .align 2^12
    .align PGSHIFT
    .global bootstack
bootstack:
    .space KSTACKSIZE
    .global bootstacktop
bootstacktop:

.section .data
    # 由于我们要把这个页表放到一个页里面，因此必须 12 位对齐
    .align PGSHIFT
    .global boot_page_table_sv39
# 分配 4KiB 内存给预设的三级页表
boot_page_table_sv39:
    # 0xffffffff_c0000000 map to 0x80000000 (1G)
    # 前 511 个页表项均设置为 0 ，因此 V=0 ，意味着是空的(unmapped)
    .zero 8 * 511
    # 设置最后一个页表项，PPN=0x80000，标志位 VRWXAD 均为 1
    .quad (0x80000 &lt;&lt; 10) | 0xcf # VRWXAD
</pre></div>
</div>
<p>总结一下，要进入虚拟内存访问方式，需要如下步骤：</p>
<ol class="simple">
<li><p>分配页表所在内存空间并初始化页表；</p></li>
<li><p>设置好页基址寄存器（指向页表起始地址）；</p></li>
<li><p>刷新 TLB。</p></li>
</ol>
<p>到现在为止，看上去复杂无比的虚拟内存空间，我们终于得以窥视一二了。</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="lab2_3_5_1_key_problems_in_seg_page.html" class="btn btn-neutral float-left" title="建立段页式管理中需要考虑的关键问题" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="../lab2_3_6/index.html" class="btn btn-neutral float-right" title="物理内存管理的设计思路" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2023, NKU.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>