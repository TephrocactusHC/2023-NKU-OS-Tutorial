<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>物理内存管理的实现 &mdash; 2023级NKU操作系统实验指导书 1.0.0 文档</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=34088549"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/translations.js?v=beaddf03"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" />
    <link rel="next" title="物理内存探测的设计思路" href="lab2_3_6_2_search_phymem_layout.html" />
    <link rel="prev" title="物理内存管理的设计思路" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            2023级NKU操作系统实验指导书
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../README/README.html">欢迎来到ucore step-by-step的世界</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab0/index.html">lab0: 预备起</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab0.5/index.html">lab0.5: 比麻雀更小的麻雀(最小可执行内核)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab1/index.html">lab1: 断, 都可以断</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">lab2:物理内存和页表</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../index.html#id1">本章内容</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../lab2-1/lab2_1_goal.html">实验目的</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../lab2-2/index.html">实验内容</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">物理内存管理</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="../index.html#id2">本节内容</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../lab2-4/lab2_4_labs_requirement.html">实验报告要求</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab3/index.html">lab3:缺页异常和页面置换</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab4/index.html">lab4:进程管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab5/index.html">lab5:用户程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab6/index.html">lab6 进程调度</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab7/index.html">lab7 同步互斥</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lab8/index.html">Lab8 文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../appendix/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">2023级NKU操作系统实验指导书</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">lab2:物理内存和页表</a></li>
          <li class="breadcrumb-item"><a href="../index.html">物理内存管理</a></li>
          <li class="breadcrumb-item"><a href="index.html">物理内存管理的设计思路</a></li>
      <li class="breadcrumb-item active">物理内存管理的实现</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/lab2/lab2-3/lab2_3_6/lab2_3_6_1_pmm_init.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>物理内存管理的实现<a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
<p>在管理虚拟内存之前，我们首先需要能够管理物理内存，毕竟所有虚拟内存页都要对应到物理内存页才能使用。</p>
<p>不妨把我们的内存管理模块划分为物理内存管理和虚拟内存管理两个模块。</p>
<p>物理内存管理应当为虚拟内存管理提供这样的接口：</p>
<ul class="simple">
<li><p>检查当前还有多少空闲的物理页，返回空闲的物理页数目</p></li>
<li><p>给出n，尝试分配n个物理页，可以返回一个起始地址和连续的物理页数目，也可能分配一些零散的物理页，返回一个连起来的链表。</p></li>
<li><p>给出起始地址和n，释放n个连续的物理页</p></li>
</ul>
<p>在<code class="docutils literal notranslate"><span class="pre">kern_init()</span></code>里，我们调用一个新函数：<code class="docutils literal notranslate"><span class="pre">pmm_init()</span></code>，<code class="docutils literal notranslate"><span class="pre">kern_init()</span></code>函数我们在之前就有学习过，这里我们只是新增一个调用<code class="docutils literal notranslate"><span class="pre">pmm_init()</span></code>的接口。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// kern/init/init.c</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">kern_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">edata</span><span class="p">[],</span><span class="w"> </span><span class="n">end</span><span class="p">[];</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">edata</span><span class="p">);</span>
<span class="w">    </span><span class="n">cons_init</span><span class="p">();</span><span class="w">  </span><span class="c1">// init the console</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;(THU.CST) os is loading ...</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">cputs</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
<span class="w">    </span><span class="n">print_kerninfo</span><span class="p">();</span>

<span class="w">    </span><span class="n">idt_init</span><span class="p">();</span><span class="w">  </span><span class="c1">// init interrupt descriptor table</span>
<span class="w">    </span><span class="n">pmm_init</span><span class="p">();</span><span class="w">  </span><span class="c1">// 新东西！</span>
<span class="w">    </span><span class="n">clock_init</span><span class="p">();</span><span class="w">   </span><span class="c1">// init clock interrupt</span>
<span class="w">    </span><span class="n">intr_enable</span><span class="p">();</span><span class="w">  </span><span class="c1">// enable irq interrupt</span>
<span class="w">    </span><span class="cm">/* do nothing */</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>那么<code class="docutils literal notranslate"><span class="pre">pmm_init()</span></code>究竟是用来干什么的呢？其实<code class="docutils literal notranslate"><span class="pre">pmm_init()</span></code>主要就是用来主要负责初始化物理内存管理，我们可以在pmm.c文件进行初始化操作。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// kern/mm/pmm.c</span>
<span class="cm">/* pmm_init - initialize the physical memory management */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">pmm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// We need to alloc/free the physical memory (granularity is 4KB or other size).</span>
<span class="w">    </span><span class="c1">// So a framework of physical memory manager (struct pmm_manager)is defined in pmm.h</span>
<span class="w">    </span><span class="c1">// First we should init a physical memory manager(pmm) based on the framework.</span>
<span class="w">    </span><span class="c1">// Then pmm can alloc/free the physical memory.</span>
<span class="w">    </span><span class="n">init_pmm_manager</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// detect physical memory space, reserve already used memory,</span>
<span class="w">    </span><span class="c1">// then use pmm-&gt;init_memmap to create free page list</span>
<span class="w">    </span><span class="n">page_init</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// use pmm-&gt;check to verify the correctness of the alloc/free function in a pmm</span>
<span class="w">    </span><span class="n">check_alloc_page</span><span class="p">();</span>

<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">boot_page_table_sv39</span><span class="p">[];</span><span class="w"> </span><span class="c1">//我们把汇编里定义的页表所在位置的符号声明进来</span>
<span class="w">    </span><span class="n">satp_virtual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pte_t</span><span class="o">*</span><span class="p">)</span><span class="n">boot_page_table_sv39</span><span class="p">;</span>
<span class="w">    </span><span class="n">satp_physical</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PADDR</span><span class="p">(</span><span class="n">satp_virtual</span><span class="p">);</span><span class="c1">//然后输出页表所在的地址</span>
<span class="w">    </span><span class="n">cprintf</span><span class="p">(</span><span class="s">&quot;satp virtual address: 0x%016lx</span><span class="se">\n</span><span class="s">satp physical address: 0x%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">satp_virtual</span><span class="p">,</span><span class="w"> </span><span class="n">satp_physical</span><span class="p">);</span>
<span class="p">}</span>

</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">check_alloc_page()</span></code>是对物理内存分配功能的一个测试。我们重点关注<code class="docutils literal notranslate"><span class="pre">page_init()</span></code></p>
<p>我们在lab2增加了一些功能，方便我们编程：</p>
<ul class="simple">
<li><p>kern/sync/sync.h：为确保内存管理修改相关数据时不被中断打断，提供两个功能，一个是保存 sstatus寄存器中的中断使能位(SIE)信息并屏蔽中断的功能，另一个是根据保存的中断使能位信息来使能中断的功能</p></li>
<li><p>libs/list.h：定义了通用双向链表结构以及相关的查找、插入等基本操作，这是建立基于链表方法的物理内存管理（以及其他内核功能）的基础。其他有类似双向链表需求的内核功能模块可直接使用 list.h 中定义的函数。</p></li>
<li><p>libs/atomic.h：定义了对一个二进制位进行读写的原子操作，确保相关操作不被中断打断。包括set_bit()设置某个二进制位的值为1, change_bit()给某个二进制位取反，test_bit()返回某个二进制位的值。</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// kern/sync/sync.h</span>
<span class="cp">#ifndef __KERN_SYNC_SYNC_H__</span>
<span class="cp">#define __KERN_SYNC_SYNC_H__</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;defs.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;intr.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;riscv.h&gt;</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">__intr_save</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">read_csr</span><span class="p">(</span><span class="n">sstatus</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">SSTATUS_SIE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">intr_disable</span><span class="p">();</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">__intr_restore</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">intr_enable</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">//思考：这里宏定义的 do{}while(0)起什么作用?</span>
<span class="cp">#define local_intr_save(x) \</span>
<span class="cp">    do {                   \</span>
<span class="cp">        x = __intr_save(); \</span>
<span class="cp">    } while (0)</span>
<span class="cp">#define local_intr_restore(x) __intr_restore(x);</span>

<span class="cp">#endif </span><span class="cm">/* !__KERN_SYNC_SYNC_H__ */</span>

</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">list.h</span></code>里面实现了一个简单的双向链表。虽然接口很多，但是只要对链表熟悉，不难理解。如果理解不了，可以先去学学数据结构这门课。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// libs/list.h</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">list_entry</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_entry</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_entry</span><span class="w"> </span><span class="n">list_entry_t</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">list_init</span><span class="p">(</span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">elm</span><span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">));</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">list_add</span><span class="p">(</span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">listelm</span><span class="p">,</span><span class="w"> </span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">elm</span><span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">));</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">list_add_before</span><span class="p">(</span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">listelm</span><span class="p">,</span><span class="w"> </span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">elm</span><span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">));</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">list_add_after</span><span class="p">(</span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">listelm</span><span class="p">,</span><span class="w"> </span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">elm</span><span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">));</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">list_del</span><span class="p">(</span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">listelm</span><span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">));</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">list_del_init</span><span class="p">(</span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">listelm</span><span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">));</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">list_empty</span><span class="p">(</span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">));</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="nf">list_next</span><span class="p">(</span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">listelm</span><span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">));</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="nf">list_prev</span><span class="p">(</span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">listelm</span><span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">));</span>
<span class="c1">//下面两个函数仅在内部使用，不对外开放作为接口。</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">__list_add</span><span class="p">(</span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">elm</span><span class="p">,</span><span class="w"> </span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">));</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">__list_del</span><span class="p">(</span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="n">list_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">));</span>

</pre></div>
</div>
<p>看起来<code class="docutils literal notranslate"><span class="pre">list.h</span></code>里面定义的<code class="docutils literal notranslate"><span class="pre">list_entry</span></code>并没有数据域，但是，如果我们把<code class="docutils literal notranslate"><span class="pre">list_entry</span></code>作为其他结构体的成员，就可以利用C语言结构体内存连续布局的特点，从``list_entry`的地址获得它所在的上一级结构体。</p>
<p>于是我们定义了可以连成链表的<code class="docutils literal notranslate"><span class="pre">Page</span></code>结构体和一系列对它做操作的宏。这个结构体用来管理物理内存。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// libs/defs.h</span>

<span class="cm">/* Return the offset of &#39;member&#39; relative to the beginning of a struct type */</span>
<span class="cp">#define offsetof(type, member)                                      \</span>
<span class="cp">    ((size_t)(&amp;((type *)0)-&gt;member))</span>

<span class="cm">/* *</span>
<span class="cm"> * to_struct - get the struct from a ptr</span>
<span class="cm"> * @ptr:    a struct pointer of member</span>
<span class="cm"> * @type:   the type of the struct this is embedded in</span>
<span class="cm"> * @member: the name of the member within the struct</span>
<span class="cm"> * */</span>
<span class="cp">#define to_struct(ptr, type, member)                               \</span>
<span class="cp">    ((type *)((char *)(ptr) - offsetof(type, member)))</span>

<span class="c1">// kern/mm/memlayout.h</span>
<span class="cm">/* *</span>
<span class="cm"> * struct Page - Page descriptor structures. Each Page describes one</span>
<span class="cm"> * physical page. In kern/mm/pmm.h, you can find lots of useful functions</span>
<span class="cm"> * that convert Page to other data types, such as physical address.</span>
<span class="cm"> * */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Page</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ref</span><span class="p">;</span><span class="w">                 </span><span class="c1">// page frame&#39;s reference counter</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w">          </span><span class="c1">// array of flags that describe the status of the page frame</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">property</span><span class="p">;</span><span class="w">   </span><span class="c1">// the num of free block, used in first fit pm manager</span>
<span class="w">    </span><span class="n">list_entry_t</span><span class="w"> </span><span class="n">page_link</span><span class="p">;</span><span class="w">  </span><span class="c1">// free list link</span>
<span class="p">};</span>

<span class="cm">/* Flags describing the status of a page frame */</span>
<span class="cp">#define PG_reserved                 0       </span><span class="c1">// if this bit=1: the Page is reserved for kernel, cannot be used in alloc/free_pages; otherwise, this bit=0</span>
<span class="cp">#define PG_property                 1       </span><span class="c1">// if this bit=1: the Page is the head page of a free memory block(contains some continuous_addrress pages), and can be used in alloc_pages; if this bit=0: if the Page is the the head page of a free memory block, then this Page and the memory block is alloced. Or this Page isn&#39;t the head page.</span>
<span class="c1">//这几个对page操作的宏用到了atomic.h的原子操作</span>
<span class="cp">#define SetPageReserved(page)       set_bit(PG_reserved, &amp;((page)-&gt;flags))</span>
<span class="cp">#define ClearPageReserved(page)     clear_bit(PG_reserved, &amp;((page)-&gt;flags))</span>
<span class="cp">#define PageReserved(page)          test_bit(PG_reserved, &amp;((page)-&gt;flags))</span>
<span class="cp">#define SetPageProperty(page)       set_bit(PG_property, &amp;((page)-&gt;flags))</span>
<span class="cp">#define ClearPageProperty(page)     clear_bit(PG_property, &amp;((page)-&gt;flags))</span>
<span class="cp">#define PageProperty(page)          test_bit(PG_property, &amp;((page)-&gt;flags))</span>

<span class="c1">// convert list entry to page</span>
<span class="cp">#define le2page(le, member)                 \</span>
<span class="cp">    to_struct((le), struct Page, member)</span>

<span class="cm">/* free_area_t - maintains a doubly linked list to record free (unused) pages */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">list_entry_t</span><span class="w"> </span><span class="n">free_list</span><span class="p">;</span><span class="w">         </span><span class="c1">// the list header</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nr_free</span><span class="p">;</span><span class="w">           </span><span class="c1">// # of free pages in this free list</span>
<span class="p">}</span><span class="w"> </span><span class="n">free_area_t</span><span class="p">;</span>

</pre></div>
</div>
<p>我们知道，物理内存通常是一片 RAM ，我们可以把它看成一个以字节为单位的大数组，通过物理地址找到对应的位置进行读写。但是，物理地址<strong>并不仅仅</strong>只能访问物理内存，也可以用来访问其他的外设，因此你也可以认为物理内存也算是一种外设。</p>
<p>这样设计是因为：如果访问其他外设要使用不同的指令（如 x86 单独提供了<strong>in</strong>, <strong>out</strong> 指令来访问不同于内存的<strong>IO</strong>地址空间），会比较麻烦，于是很多 CPU（如 RISC-V，ARM，MIPS 等）通过 MMIO(Memory Mapped I/O) 技术将外设映射到一段物理地址，这样我们访问其他外设就和访问物理内存一样啦！</p>
<p>我们先不管那些外设，目前我们只关注物理内存。</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="index.html" class="btn btn-neutral float-left" title="物理内存管理的设计思路" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="lab2_3_6_2_search_phymem_layout.html" class="btn btn-neutral float-right" title="物理内存探测的设计思路" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2023, NKU.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>