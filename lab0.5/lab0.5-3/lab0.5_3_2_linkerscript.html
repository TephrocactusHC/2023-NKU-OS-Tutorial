<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>内存布局，链接脚本，入口点 &mdash; 2023级NKU操作系统实验指导书 1.0.0 文档</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=34088549"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/translations.js?v=beaddf03"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="“真正的”入口点" href="lab0.5_3_3_kern_init.html" />
    <link rel="prev" title="OpenSBI, bin, elf" href="lab0.5_3_1_layout.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            2023级NKU操作系统实验指导书
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../README/README.html">欢迎来到ucore step-by-step的世界</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab0/index.html">lab0: 预备起</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">lab0.5: 比麻雀更小的麻雀(最小可执行内核)</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#id1">本章内容</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../lab0.5-1/lab0.5_1_goals.html">实验目的：</a></li>
<li class="toctree-l3"><a class="reference internal" href="../lab0.5-2/index.html">实验内容</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">从机器启动到操作系统运行的过程</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="index.html#id2">本节内容</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../lab0.5-4/lab0.5_4_requirement.html">实验报告要求</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../lab1/index.html">lab1: 断, 都可以断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab2/index.html">lab2:物理内存和页表</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab3/index.html">lab3:缺页异常和页面置换</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab4/index.html">lab4:进程管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab5/index.html">lab5:用户程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab6/index.html">lab6 进程调度</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab7/index.html">lab7 同步互斥</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab8/index.html">Lab8 文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../appendix/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">2023级NKU操作系统实验指导书</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">lab0.5: 比麻雀更小的麻雀(最小可执行内核)</a></li>
          <li class="breadcrumb-item"><a href="index.html">从机器启动到操作系统运行的过程</a></li>
      <li class="breadcrumb-item active">内存布局，链接脚本，入口点</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/lab0.5/lab0.5-3/lab0.5_3_2_linkerscript.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>内存布局，链接脚本，入口点<a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
<p>一般来说，一个程序按照功能不同会分为下面这些段：</p>
<p>.text 段，即代码段，存放汇编代码；
.rodata 段，即只读数据段，顾名思义里面存放只读数据，通常是程序中的常量；
.data 段，存放被初始化的可读写数据，通常保存程序中的全局变量；
.bss 段，存放被初始化为 00 的可读写数据，与 .data 段的不同之处在于我们知道它要被初始化为 00 ，因此在可执行文件中只需记录这个段的大小以及所在位置即可，而不用记录里面的数据。
stack ，即栈，用来存储程序运行过程中的局部变量，以及负责函数调用时的各种机制。它从高地址向低地址增长；
heap ，即堆，用来支持程序运行过程中内存的动态分配，比如说你要读进来一个字符串，在你写程序的时候你也不知道它的长度究竟为多少，于是你只能在运行过程中，知道了字符串的长度之后，再在堆中给这个字符串分配内存。
内存布局，也就是指这些段各自所放的位置。一种典型的内存布局如下：</p>
<p><img alt="" src="../../_images/program_memory_layout.png" /></p>
<p>gnu工具链中，包含一个链接器<code class="docutils literal notranslate"><span class="pre">ld</span></code></p>
<p>如果你很好奇，可以看<a class="reference external" href="http://www.scoberlin.de/content/media/http/informatik/gcc_docs/ld_3.html">linker script的详细语法</a></p>
<p>链接器的作用是把输入文件(往往是 .o文件)链接成输出文件(往往是elf文件)。一般来说，输入文件和输出文件都有很多section, 链接脚本(linker script)的作用，就是描述怎样把输入文件的section映射到输出文件的section, 同时规定这些section的内存布局。</p>
<p>如果你不提供链接脚本，ld会使用默认的一个链接脚本，这个默认的链接脚本适合链接出一个能在现有操作系统下运行的应用程序，但是并不适合链接一个操作系统内核。你可以通过<code class="docutils literal notranslate"><span class="pre">ld</span> <span class="pre">--verbose</span></code>来查看默认的链接脚本。</p>
<p>下面给出我们使用的链接脚本</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* tools/kernel.ld */</span>

<span class="n">OUTPUT_ARCH</span><span class="p">(</span><span class="n">riscv</span><span class="p">)</span><span class="w"> </span><span class="cm">/* 指定输出文件的指令集架构, 在riscv平台上运行 */</span>
<span class="n">ENTRY</span><span class="p">(</span><span class="n">kern_entry</span><span class="p">)</span><span class="w">  </span><span class="cm">/* 指定程序的入口点, 是一个叫做kern_entry的符号。我们之后会在汇编代码里定义它*/</span>

<span class="n">BASE_ADDRESS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x80200000</span><span class="p">;</span><span class="cm">/*定义了一个变量BASE_ADDRESS并初始化 */</span>

<span class="cm">/*链接脚本剩余的部分是一整条SECTIONS指令，用来指定输出文件的所有SECTION</span>
<span class="cm"> &quot;.&quot; 是SECTIONS指令内的一个特殊变量/计数器，对应内存里的一个地址。*/</span>
<span class="n">SECTIONS</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Load the kernel at this address: &quot;.&quot; means the current address */</span>
<span class="w">    </span><span class="p">.</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BASE_ADDRESS</span><span class="p">;</span><span class="cm">/*对 &quot;.&quot;进行赋值*/</span>
<span class="w">	</span><span class="cm">/* 下面一句的意思是：从.的当前值（当前地址）开始放置一个叫做text的section. </span>
<span class="cm">	 花括号内部的*(.text.kern_entry .text .stub .text.* .gnu.linkonce.t.*)是正则表达式</span>
<span class="cm">	 如果输入文件中有一个section的名称符合花括号内部的格式</span>
<span class="cm">	 那么这个section就被加到输出文件的text这个section里</span>
<span class="cm">	 输入文件中section的名称,有些是编译器自动生成的,有些是我们自己定义的*/</span>
<span class="w">    </span><span class="p">.</span><span class="n">text</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="p">(.</span><span class="n">text</span><span class="p">.</span><span class="n">kern_entry</span><span class="p">)</span><span class="w"> </span><span class="cm">/*把输入中kern_entry这一段放到输出中text的开头*/</span>
<span class="w">        </span><span class="o">*</span><span class="p">(.</span><span class="n">text</span><span class="w"> </span><span class="p">.</span><span class="n">stub</span><span class="w"> </span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="p">.</span><span class="n">gnu</span><span class="p">.</span><span class="n">linkonce</span><span class="p">.</span><span class="n">t</span><span class="p">.</span><span class="o">*</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">PROVIDE</span><span class="p">(</span><span class="n">etext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.);</span><span class="w"> </span><span class="cm">/* Define the &#39;etext&#39; symbol to this value */</span>
<span class="w">	</span><span class="cm">/*read only data, 只读数据，如程序里的常量*/</span>
<span class="w">    </span><span class="p">.</span><span class="n">rodata</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="p">(.</span><span class="n">rodata</span><span class="w"> </span><span class="p">.</span><span class="n">rodata</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="p">.</span><span class="n">gnu</span><span class="p">.</span><span class="n">linkonce</span><span class="p">.</span><span class="n">r</span><span class="p">.</span><span class="o">*</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* 进行地址对齐，将 &quot;.&quot;增加到 2的0x1000次方的整数倍，也就是下一个内存页的起始处 */</span>
<span class="w">    </span><span class="p">.</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ALIGN</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">);</span>

<span class="w">  	</span>
<span class="w">    </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="p">(.</span><span class="n">data</span><span class="p">)</span>
<span class="w">        </span><span class="o">*</span><span class="p">(.</span><span class="n">data</span><span class="p">.</span><span class="o">*</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">	</span><span class="cm">/* small data section, 存储字节数小于某个标准的变量，一般是char, short等类型的 */</span>
<span class="w">    </span><span class="p">.</span><span class="n">sdata</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="p">(.</span><span class="n">sdata</span><span class="p">)</span>
<span class="w">        </span><span class="o">*</span><span class="p">(.</span><span class="n">sdata</span><span class="p">.</span><span class="o">*</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">PROVIDE</span><span class="p">(</span><span class="n">edata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.);</span>
<span class="w">	</span><span class="cm">/* 初始化为零的数据 */</span>
<span class="w">    </span><span class="p">.</span><span class="n">bss</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="p">(.</span><span class="n">bss</span><span class="p">)</span>
<span class="w">        </span><span class="o">*</span><span class="p">(.</span><span class="n">bss</span><span class="p">.</span><span class="o">*</span><span class="p">)</span>
<span class="w">        </span><span class="o">*</span><span class="p">(.</span><span class="n">sbss</span><span class="o">*</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">PROVIDE</span><span class="p">(</span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.);</span>
<span class="w">	</span><span class="cm">/* /DISCARD/表示忽略，输入文件里 *(.eh_frame .note.GNU-stack)这些section都被忽略，不会加入到输出文件中 */</span>
<span class="w">    </span><span class="o">/</span><span class="n">DISCARD</span><span class="o">/</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="p">(.</span><span class="n">eh_frame</span><span class="w"> </span><span class="p">.</span><span class="n">note</span><span class="p">.</span><span class="n">GNU</span><span class="o">-</span><span class="n">stack</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<blockquote>
<div><p>趣闻</p>
<p>为什么把初始化为0（或者说，无需初始化）的数据段称作bss?</p>
<p>CSAPP 7.4 Relocatable Object files</p>
<p>Aside Why is uninitialized data called .bss?
The use of the term .bss to denote uninitialized data is universal. It was originally an acronym for the
“block started by symbol” directive from the IBM 704 assembly language (circa 1957) and the acronym
has stuck. A simple way to remember the difference between the .data and .bss sections is to think
of “bss” as an abbreviation for “Better Save Space!”</p>
</div></blockquote>
<p>我们在链接脚本里把程序的入口点定义为<code class="docutils literal notranslate"><span class="pre">kern_entry</span></code>, 那么我们的程序里需要有一个名称为<code class="docutils literal notranslate"><span class="pre">kern_entry</span></code>的符号。我们在<code class="docutils literal notranslate"><span class="pre">kern/init/entry.S</span></code>编写一段汇编代码, 作为整个内核的入口点。</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="c1"># kern/init/entry.S</span>
<span class="c1">#include &lt;mmu.h&gt;</span>
<span class="c1">#include &lt;memlayout.h&gt;</span>

<span class="c1"># The ,&quot;ax&quot;,@progbits tells the assembler that the section is allocatable (&quot;a&quot;), executable (&quot;x&quot;) and contains data (&quot;@progbits&quot;).</span>
<span class="c1"># 从这里开始.text 这个section, &quot;ax&quot; 和 %progbits描述这个section的特征</span>
<span class="c1"># https://www.nongnu.org/avr-libc/user-manual/mem_sections.html</span>
<span class="na">.section</span><span class="w"> </span><span class="no">.text</span><span class="p">,</span><span class="s">&quot;ax&quot;</span><span class="p">,</span><span class="nv">%progbits</span><span class="w"> </span>
<span class="w">    </span><span class="no">.globl</span><span class="w"> </span><span class="no">kern_entry</span><span class="w"> </span><span class="c1"># 使得ld能够看到kern_entry这个符号所在的位置, globl和global同义</span>
<span class="w">    </span><span class="c1"># https://sourceware.org/binutils/docs/as/Global.html#Global</span>
<span class="nl">kern_entry:</span><span class="w"> </span>
<span class="w">    </span><span class="nf">la</span><span class="w"> </span><span class="no">sp</span><span class="p">,</span><span class="w"> </span><span class="no">bootstacktop</span><span class="w"> </span>
<span class="w">    </span><span class="no">tail</span><span class="w"> </span><span class="no">kern_init</span><span class="w"> </span>
<span class="c1">#开始data section</span>
<span class="na">.section</span><span class="w"> </span><span class="no">.data</span>
<span class="w">    </span><span class="na">.align</span><span class="w"> </span><span class="no">PGSHIFT</span><span class="w"> </span><span class="c1">#按照2^PGSHIFT进行地址对齐, 也就是对齐到下一页 PGSHIFT在 mmu.h定义</span>
<span class="w">    </span><span class="na">.global</span><span class="w"> </span><span class="no">bootstack</span><span class="w"> </span><span class="c1">#内核栈</span>
<span class="nl">bootstack:</span>
<span class="w">    </span><span class="na">.space</span><span class="w"> </span><span class="no">KSTACKSIZE</span><span class="w"> </span><span class="c1">#留出KSTACKSIZE这么多个字节的内存</span>
<span class="w">    </span><span class="na">.global</span><span class="w"> </span><span class="no">bootstacktop</span><span class="w"> </span><span class="c1">#之后内核栈将要从高地址向低地址增长, 初始时的内核栈为空</span>
<span class="nl">bootstacktop:</span><span class="w">                              </span>
</pre></div>
</div>
<p>现在这个入口点，作用就是分配好内核栈，然后跳转到<code class="docutils literal notranslate"><span class="pre">kern_init</span></code>, 看来这个<code class="docutils literal notranslate"><span class="pre">kern_init</span></code>才是我们真正的入口点。下面我们就来看看它。</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="lab0.5_3_1_layout.html" class="btn btn-neutral float-left" title="OpenSBI, bin, elf" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="lab0.5_3_3_kern_init.html" class="btn btn-neutral float-right" title="“真正的”入口点" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2023, NKU.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>