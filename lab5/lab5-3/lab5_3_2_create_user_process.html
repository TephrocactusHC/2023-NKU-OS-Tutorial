<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>创建用户进程 &mdash; 2023级NKU操作系统实验指导书 1.0.0 文档</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/translations.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="进程退出和等待进程" href="lab5_3_3_process_exit_wait.html" />
    <link rel="prev" title="实验执行流程概述" href="lab5_3_1_lab_steps.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            2023级NKU操作系统实验指导书
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../README/README.html">欢迎来到ucore step-by-step的世界</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab0/index.html">lab0: 预备起</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab0.5/index.html">lab0.5: 比麻雀更小的麻雀(最小可执行内核)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab1/index.html">lab1: 断, 都可以断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab2/index.html">lab2:物理内存和页表</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab3/index.html">lab3:缺页异常和页面置换</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab4/index.html">lab4:进程管理</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">lab5:用户程序</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#id1">本章内容</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../lab5-1/lab5_1_goals.html">实验目的</a></li>
<li class="toctree-l3"><a class="reference internal" href="../lab5-2/index.html">实验内容</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">用户进程管理</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="index.html#id2">本节内容</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../lab5-4/lab5_4_lab_requirement.html">实验报告要求</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../lab6/index.html">lab6 进程调度</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab7/index.html">lab7 同步互斥</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab8/index.html">Lab8 文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../appendix/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">2023级NKU操作系统实验指导书</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">lab5:用户程序</a></li>
          <li class="breadcrumb-item"><a href="index.html">用户进程管理</a></li>
      <li class="breadcrumb-item active">创建用户进程</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/lab5/lab5-3/lab5_3_2_create_user_process.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>创建用户进程<a class="headerlink" href="#id1" title="永久链接至标题"></a></h1>
<p>在实验四中，我们已经完成了对内核线程的创建，但与用户进程的创建过程相比，创建内核线程的过程还远远不够。而这两个创建过程的差异本质上就是用户进程和内核线程的差异决定的。</p>
<section id="id2">
<h2>1. 应用程序的组成和编译<a class="headerlink" href="#id2" title="永久链接至标题"></a></h2>
<p>我们首先来看一个应用程序，这里我们假定是hello应用程序，在user/hello.c中实现，代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;ulib.h&gt;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cprintf</span><span class="p">(</span><span class="s2">&quot;Hello world!!.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">cprintf</span><span class="p">(</span><span class="s2">&quot;I am process </span><span class="si">%d</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="n">cprintf</span><span class="p">(</span><span class="s2">&quot;hello pass.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>hello应用程序只是输出一些字符串，并通过系统调用sys_getpid（在getpid函数中调用）输出代表hello应用程序执行的用户进程的进程标识–pid。</p>
<p>首先，我们需要了解ucore操作系统如何能够找到hello应用程序。这需要分析ucore和hello是如何编译的。修改Makefile，把第六行注释掉。然后在本实验源码目录下执行make，可得到如下输出：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>……
+ cc user/hello.c
riscv64-unknown-elf-gcc -Iuser/ -mcmodel=medany -O2 -std=gnu99 -Wno-unused -fno-builtin -Wall -nostdinc  -fno-stack-protector -ffunction-sections -fdata-sections -Ilibs/ -Iuser/include/ -Iuser/libs/ -c user/hello.c -o obj/user/hello.o
+ cc user/libs/panic.c
riscv64-unknown-elf-gcc -Iuser/libs/ -mcmodel=medany -O2 -std=gnu99 -Wno-unused -fno-builtin -Wall -nostdinc  -fno-stack-protector -ffunction-sections -fdata-sections -Ilibs/ -Iuser/include/ -Iuser/libs/ -c user/libs/panic.c -o obj/user/libs/panic.o
...
</pre></div>
</div>
<p>从中可以看出，hello应用程序不仅仅是hello.c，还包含了支持hello应用程序的用户态库：</p>
<ul class="simple">
<li><p>user/libs/initcode.S：所有应用程序的起始用户态执行地址“_start”，调整了EBP和ESP后，调用umain函数。</p></li>
<li><p>user/libs/umain.c：实现了umain函数，这是所有应用程序执行的第一个C函数，它将调用应用程序的main函数，并在main函数结束后调用exit函数，而exit函数最终将调用sys_exit系统调用，让操作系统回收进程资源。</p></li>
<li><p>user/libs/ulib.[ch]：实现了最小的C函数库，除了一些与系统调用无关的函数，其他函数是对访问系统调用的包装。</p></li>
<li><p>user/libs/syscall.[ch]：用户层发出系统调用的具体实现。</p></li>
<li><p>user/libs/stdio.c：实现cprintf函数，通过系统调用sys_putc来完成字符输出。</p></li>
<li><p>user/libs/panic.c：实现__panic/__warn函数，通过系统调用sys_exit完成用户进程退出。</p></li>
</ul>
<p>除了这些用户态库函数实现外，还有一些libs/*.[ch]是操作系统内核和应用程序共用的函数实现。这些用户库函数其实在本质上与UNIX系统中的标准libc没有区别，只是实现得很简单，但hello应用程序的正确执行离不开这些库函数。</p>
<p>【注意】libs/*.[ch]、user/libs/*.[ch]、user/*.[ch]的源码中没有任何特权指令。</p>
<p>在make的最后一步执行了一个ld命令，把hello应用程序的执行码obj/__user_hello.out连接在了ucore kernel的末尾。且ld命令会在kernel中会把__user_hello.out的位置和大小记录在全局变量_binary_obj___user_hello_out_start和_binary_obj___user_hello_out_size中，这样这个hello用户程序就能够和ucore内核一起被 bootloader 加载到内存里中，并且通过这两个全局变量定位hello用户程序执行码的起始位置和大小。而到了与文件系统相关的实验后，ucore会提供一个简单的文件系统，那时所有的用户程序就都不再用这种方法进行加载了，而可以用大家熟悉的文件方式进行加载了。</p>
</section>
<section id="id3">
<h2>2. 用户进程的虚拟地址空间<a class="headerlink" href="#id3" title="永久链接至标题"></a></h2>
<p>在tools/user.ld描述了用户程序的用户虚拟空间的执行入口虚拟地址：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SECTIONS</span> <span class="p">{</span>
    <span class="o">/*</span> <span class="n">Load</span> <span class="n">programs</span> <span class="n">at</span> <span class="n">this</span> <span class="n">address</span><span class="p">:</span> <span class="s2">&quot;.&quot;</span> <span class="n">means</span> <span class="n">the</span> <span class="n">current</span> <span class="n">address</span> <span class="o">*/</span>
    <span class="o">.</span> <span class="o">=</span> <span class="mh">0x800020</span><span class="p">;</span>
</pre></div>
</div>
<p>在tools/kernel.ld描述了操作系统的内核虚拟空间的起始入口虚拟地址：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BASE_ADDRESS</span> <span class="o">=</span> <span class="mh">0xFFFFFFFFC0200000</span><span class="p">;</span>

<span class="n">SECTIONS</span>
<span class="p">{</span>
    <span class="o">/*</span> <span class="n">Load</span> <span class="n">the</span> <span class="n">kernel</span> <span class="n">at</span> <span class="n">this</span> <span class="n">address</span><span class="p">:</span> <span class="s2">&quot;.&quot;</span> <span class="n">means</span> <span class="n">the</span> <span class="n">current</span> <span class="n">address</span> <span class="o">*/</span>
    <span class="o">.</span> <span class="o">=</span> <span class="n">BASE_ADDRESS</span><span class="p">;</span>
</pre></div>
</div>
<p>这样ucore把用户进程的虚拟地址空间分了两块，一块与内核线程一样，是所有用户进程都共享的内核虚拟地址空间，映射到同样的物理内存空间中，这样在物理内存中只需放置一份内核代码，使得用户进程从用户态进入核心态时，内核代码可以统一应对不同的内核程序；另外一块是用户虚拟地址空间，虽然虚拟地址范围一样，但映射到不同且没有交集的物理内存空间中。这样当ucore把用户进程的执行代码（即应用程序的执行代码）和数据（即应用程序的全局变量等）放到用户虚拟地址空间中时，确保了各个进程不会“非法”访问到其他进程的物理内存空间。</p>
<p>这样ucore给一个用户进程具体设定的虚拟内存空间（kern/mm/memlayout.h）如下所示：</p>
<p><img alt="image" src="../../_images/image001.png" /></p>
</section>
<section id="id4">
<h2>3. 创建并执行用户进程<a class="headerlink" href="#id4" title="永久链接至标题"></a></h2>
<p>在确定了用户进程的执行代码和数据，以及用户进程的虚拟空间布局后，我们可以来创建用户进程了。在本实验中第一个用户进程是由第二个内核线程initproc通过把hello应用程序执行码覆盖到initproc的用户虚拟内存空间来创建的，相关代码如下所示：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// kern/process/proc.c</span>
<span class="cp">#define __KERNEL_EXECVE(name, binary, size) ({                          \</span>
<span class="cp">            cprintf(&quot;kernel_execve: pid = %d, name = \&quot;%s\&quot;.\n&quot;,        \</span>
<span class="cp">                    current-&gt;pid, name);                                \</span>
<span class="cp">            kernel_execve(name, binary, (size_t)(size));                \</span>
<span class="cp">        })</span>

<span class="cp">#define KERNEL_EXECVE(x) ({                                             \</span>
<span class="cp">            extern unsigned char _binary_obj___user_##x##_out_start[],  \</span>
<span class="cp">                _binary_obj___user_##x##_out_size[];                    \</span>
<span class="cp">            __KERNEL_EXECVE(#x, _binary_obj___user_##x##_out_start,     \</span>
<span class="cp">                            _binary_obj___user_##x##_out_size);         \</span>
<span class="cp">        })</span>

<span class="cp">#define __KERNEL_EXECVE2(x, xstart, xsize) ({                           \</span>
<span class="cp">            extern unsigned char xstart[], xsize[];                     \</span>
<span class="cp">            __KERNEL_EXECVE(#x, xstart, (size_t)xsize);                 \</span>
<span class="cp">        })</span>

<span class="cp">#define KERNEL_EXECVE2(x, xstart, xsize)        __KERNEL_EXECVE2(x, xstart, xsize)</span>

<span class="c1">// user_main - kernel thread used to exec a user program</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="nf">user_main</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#ifdef TEST</span>
<span class="w">    </span><span class="n">KERNEL_EXECVE2</span><span class="p">(</span><span class="n">TEST</span><span class="p">,</span><span class="w"> </span><span class="n">TESTSTART</span><span class="p">,</span><span class="w"> </span><span class="n">TESTSIZE</span><span class="p">);</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">KERNEL_EXECVE</span><span class="p">(</span><span class="n">exit</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">&quot;user_main execve failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>对于上述代码，我们需要从后向前按照函数/宏的实现一个一个来分析。Initproc的执行主体是init_main函数，这个函数在缺省情况下是执行宏KERNEL_EXECVE(hello)，而这个宏最终是调用kernel_execve函数来调用SYS_exec系统调用，由于ld在链接hello应用程序执行码时定义了两全局变量：</p>
<ul class="simple">
<li><p>_binary_obj___user_hello_out_start：hello执行码的起始位置</p></li>
<li><p>_binary_obj___user_hello_out_size中：hello执行码的大小</p></li>
</ul>
<p>kernel_execve把这两个变量作为SYS_exec系统调用的参数，让ucore来创建此用户进程。当ucore收到此系统调用后，将依次调用如下函数</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>vector128(vectors.S)--\&gt;
\_\_alltraps(trapentry.S)--\&gt;trap(trap.c)--\&gt;trap\_dispatch(trap.c)--
--\&gt;syscall(syscall.c)--\&gt;sys\_exec（syscall.c）--\&gt;do\_execve(proc.c)
</pre></div>
</div>
<p>最终通过do_execve函数来完成用户进程的创建工作。此函数的主要工作流程如下：</p>
<ul class="simple">
<li><p>首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的initproc是内核线程，所以mm为NULL，整个处理都不会做。</p></li>
<li><p>接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。load_icode函数完成了整个复杂的工作。</p></li>
</ul>
<p>load_icode函数的主要工作就是给用户进程建立一个能够让用户进程正常运行的用户环境。此函数有一百多行，完成了如下重要工作：</p>
<ol class="simple">
<li><p>调用mm_create函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化；</p></li>
<li><p>调用setup_pgdir来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（boot_pgdir所指）的内容拷贝到此新目录表中，最后让mm-&gt;pgdir指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核虚空间；</p></li>
<li><p>根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用mm_map函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等）的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间；</p></li>
<li><p>调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；</p></li>
<li><p>需要给用户进程设置用户栈，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址&lt;–&gt;物理地址映射关系；</p></li>
<li><p>至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把mm-&gt;pgdir赋值到cr3寄存器中，即更新了用户进程的虚拟内存空间，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；</p></li>
<li><p>先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断；</p></li>
</ol>
<p>至此，用户进程的用户环境已经搭建完毕。此时initproc将按产生系统调用的函数调用路径原路返回，执行中断返回指令“iret”（位于trapentry.S的最后一句）后，将切换到用户进程hello的第一条语句位置_start处（位于user/libs/initcode.S的第三句）开始执行。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="lab5_3_1_lab_steps.html" class="btn btn-neutral float-left" title="实验执行流程概述" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="lab5_3_3_process_exit_wait.html" class="btn btn-neutral float-right" title="进程退出和等待进程" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2023, NKU.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>